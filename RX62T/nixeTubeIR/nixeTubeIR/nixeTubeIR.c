/***********************************************************************/
/*                                                                     */
/*  FILE        :74HC595.c                                             */
/*  DATE        :Fri, May 31, 2019                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :RX62T                                                 */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.51).    */
/*  NOTE:THIS IS A TYPICAL EXAMPLE.                                    */
/*                                                                     */
/***********************************************************************/
                  


//#include "typedefine.h"
#ifdef __cplusplus
//#include <ios>                        // Remove the comment when you use ios
//_SINT ios_base::Init::init_cnt;       // Remove the comment when you use ios
#endif

void main(void);
#ifdef __cplusplus
extern "C" {
void abort(void);
}
#endif

enum IRcode{
	power = 0x7fd12e,
	IRmode = 0x7fb14e,
	mute = 0x7ff10e,
	pause = 0x7f916e,
	previous = 0x7f817e,
	next = 0x7fe11e,
	EQ = 0x7ff00f,
	volDecrease=0x7fd42b,
	volIncrease=0x7fc837,
	zero = 0x7fb44b,
	one =0x7f9867 ,
	two=0x7f8c73,
	three=0x7fbd42,
	four=0x7f8877,
	five=0x7f9c63,
	six=0x7fad52,
	seven=0x7fa15e,
	eight=0x7fa55a,
	nine=0x7fa956,
	forceEnumTo32bit=0xffffff
};
/*status mode */
void powerOFFHandle(void);
void powerOnHandle(void);
void setLedHandle(void);
void setTubeHandle(void);
void bluetoothHandle(void);
void FMradioHandle(void);
/////////////


void ledRest(void);
void TubeRest(void);
void RestValue(void);
void ControlTube(unsigned int tube,unsigned int num);
void updateTube(void);
void RGBledPWM(unsigned char led,unsigned char color,unsigned char bright);
void RGBledControl(unsigned char led,unsigned char color);
void RGBledUpdate(void);
void ledControl(unsigned char led,unsigned char colorValue);
void modifyTubeValue(unsigned char TubeValue);
void timeReverseUpdate(unsigned int h,unsigned int m,unsigned int s);

void FMsend(unsigned char *buffer);
void tea5767SetFrequency( unsigned long frequency );
////////////IR////////
unsigned long bitPattern=0,newKey=0;
unsigned char msCount=0,timerValue=0;
char pulseCount=0;
///////////////////

unsigned char i=0,data[24]={	1,1,1,1,1,1,1,1,
						1,1,1,1,1,1,1,1,
						1,1,1,1,1,1,1,1};
						
unsigned char ledData[24] = {1,1,1,1,1,1,1,1,
						1,1,1,1,1,1,1,1,
						1,1,1,1,1,1,1,1};

unsigned char OneSecFlag=1,temp,temp1;
unsigned char cmt1Count=0;
unsigned int f_IICTX,f_IICRX;
struct timeFormat {
	unsigned long totalSec;
	unsigned int hour,min,sec;	
	unsigned char hour0Val,hour1Val,min0Val,min1Val,sec0Val,sec1Val;
}*time;

void timeUpdate(){
	time->hour = time->totalSec/3600;
	time->min = time->totalSec/60-time->hour*60; 
	time->sec = time->totalSec % 60;

	time->hour1Val = time->hour/10;
	time->hour0Val = time->hour%10;

	time->min1Val = time->min/10;
	time->min0Val = time->min%10;

	time->sec1Val = time->sec/10;
	time->sec0Val = time->sec%10;

	ControlTube(0,time->hour1Val);
	ControlTube(1,time->hour0Val);

	ControlTube(2,time->min1Val);
	ControlTube(3,time->min0Val);
	
	ControlTube(4,time->sec1Val);
	ControlTube(5,time->sec0Val);

	updateTube();
}
void timeReverseUpdate(unsigned int h,unsigned int m,unsigned int s){
	time->totalSec = h*3600+m*60+s; 
}
enum status{
	powerOFF,
	powerOn,
	setLed,
	setTube,
	bluetooth,
	FMradio
}mode;
unsigned char firstEnterMode=0,enTubeFlag=0,twinkling=0;
unsigned char ledValue=63,colorValue=0,brightValue=0;
unsigned char muteFlag=0,breathFlag=0;
void main(void)
{
	RestValue();

	R_PG_Clock_Set();
	R_PG_IO_PORT_Set_P3();
	R_PG_IO_PORT_Set_P7();
	R_PG_IO_PORT_Set_P9();
	R_PG_ExtInterrupt_Set_IRQ0();
	
	TubeRest();
	ledRest();
	R_PG_Timer_Start_CMT_U0_C0();
	R_PG_Timer_Start_CMT_U0_C1();
	R_PG_Timer_Start_CMT_U1_C2();
	R_PG_Timer_Start_CMT_U1_C3();
	
	R_PG_I2C_Set_C0();
	
	R_PG_IO_PORT_Write_P30(0);
	R_PG_IO_PORT_Write_P31(0);
	mode = powerOFF;

	while(1){
		switch (mode)
		{
		case powerOFF:
			if(newKey == power){
				mode = powerOn;
				newKey = 0;
				firstEnterMode=1;
			}
			break;
		case powerOn:
			if(newKey==power){
				mode = powerOFF;
				newKey=0;
				firstEnterMode=1;
			}else if(newKey == IRmode){
				mode = setTube;
				newKey=0;
				firstEnterMode=1;
			}
			break;
		case setTube:
			if(newKey==power){
				mode = powerOFF;
				newKey=0;
				firstEnterMode=1;
			}else if(newKey == IRmode){
				mode = setLed;
				newKey=0;
				firstEnterMode=1;
			}
			break;
		case setLed:
			if(newKey==power){
				mode=powerOFF;
				newKey=0;
				firstEnterMode=1;
			}else if(newKey==IRmode){
				mode=bluetooth;
				newKey=0;
				firstEnterMode=1;
			}
			break;
		case FMradio:
			if(newKey==power){
				mode=powerOFF;
				newKey=0;
				firstEnterMode=1;
			}else if(newKey==IRmode){
				mode=powerOn;
				newKey=0;
				firstEnterMode=1;
			}
		case bluetooth:
			if(newKey==power){
				mode=powerOFF;
				newKey=0;
				firstEnterMode=1;
			}else if(newKey==IRmode){
				mode = FMradio;
				newKey=0;
				firstEnterMode=1;
			}
		default:
			break;
		}
		if(newKey == mute){
			muteFlag = !muteFlag;
			newKey=0;
		}

		switch (mode)
		{
		case powerOFF:
			powerOFFHandle();
			break;
		case powerOn:
			powerOnHandle();
			break;
		case setTube:
			setTubeHandle();
			break;
		case setLed:
			setLedHandle();
			break;
		case FMradio:
			FMradioHandle();
			break;
		case bluetooth:
			bluetoothHandle();
			break;
		
		default:
			break;
		}	
	
	}
	
}

void powerOFFHandle(void){
	enTubeFlag=0;
	if(firstEnterMode){
		twinkling=0;
		for(i=0;i<6;i++){
			ControlTube(i,0xf);
		}
		updateTube();
		brightValue=0;
		firstEnterMode=0;
		R_PG_IO_PORT_Write_P30(0); //off bluetooth
		R_PG_IO_PORT_Write_P31(0); //off fm radio
		breathFlag=0;
	}
	
}
void powerOnHandle(void){
	if(firstEnterMode){
		twinkling=0;
		timeUpdate();	
		firstEnterMode=0;
		colorValue=6;
		brightValue=128;
	}
	enTubeFlag=1;
}
unsigned char ledMode=0;
void setLedHandle(void){
	if(firstEnterMode){
		twinkling=0;
		firstEnterMode=0;
	}
	
	if(newKey == 0x7ff00f){
		breathFlag=!breathFlag;
		newKey=0;
	}
	if(breathFlag == 0){
		if(newKey == volIncrease){
			if(brightValue+16<255){
				brightValue+=16;
			}else
			{
				brightValue=255;
			}
			newKey=0;
		}
	}
	if(newKey == volDecrease){
		if(brightValue-16>0){
			brightValue-=16;
		}else
		{
			brightValue=0;
		}
		newKey=0;
	}
	
	if(newKey!=0){
		switch (newKey)
		{
		case zero:
			colorValue=0;
			break;
		case one:
			colorValue=1;
			break;
		case two:
			colorValue=2;
			break;
		case three:
			colorValue=3;
			break;
		case four:
			colorValue=4;
			break;
		case five:
			colorValue=5;
			break;
		case six:
			colorValue=6;
			break;
		case seven:
			colorValue=7;
			break;
		case eight:
			
			break;
		case nine:
			break;

		default:
			break;
		
		}
		newKey=0;	
	}

	
}
unsigned char pauseFlag=0;
enum setTime{
	sec0=5,sec1=4,min0=3,min1=2,hour0=1,hour1=0
}setTimeFLag=sec0;
unsigned int volTempArray[6]={36000,3600,600,60,10,1};
void setTubeHandle(void){
	if(firstEnterMode){
		setTimeFLag=sec0;
		twinkling=1;
		firstEnterMode=0;
	}
	if(newKey==pause){
		pauseFlag=!pauseFlag;	
		newKey=0;
	}
	if(newKey==previous){
		if(setTimeFLag<=0){
			setTimeFLag = sec0;
		}else{
			setTimeFLag--;
		}
		
		newKey=0;
	}
	if(newKey==next){
		if(setTimeFLag>=5){
			setTimeFLag=hour1;
		}else{
			setTimeFLag++;
		}
		newKey=0;
	}
	if(newKey==volIncrease || newKey==volDecrease){
		unsigned char volTemp;
		if(newKey == volIncrease){
			volTemp=1;
		}else if(newKey == volDecrease){
			volTemp=0;
		}

		if(volTemp){
			if(time->totalSec+volTempArray[setTimeFLag]<86400){
				time->totalSec=time->totalSec+volTempArray[setTimeFLag];
			}
		}else{
			if(volTempArray[setTimeFLag]<time->totalSec){
				time->totalSec=time->totalSec-volTempArray[setTimeFLag];
			}
		}
		
		newKey=0;
	}
	if(newKey!=0){
		switch (newKey)
		{
		case zero:
			modifyTubeValue(0);
			break;
		case one:
			modifyTubeValue(1);
			break;
		case two:
			modifyTubeValue(2);
			break;
		case three:
			modifyTubeValue(3);
			break;
		case four:
			modifyTubeValue(4);
			break;
		case five:
			modifyTubeValue(5);
			break;
		case six:
			modifyTubeValue(6);
			break;
		case seven:
			modifyTubeValue(7);
			break;
		case eight:
			modifyTubeValue(8);
			break;
		case nine:
			modifyTubeValue(9);
			break;

		default:
			break;
		}
		newKey=0;
		timeUpdate();	
	}
}
void modifyTubeValue(unsigned char TubeValue){
	switch (setTimeFLag)
	{
	case hour1:
		if(TubeValue<2){
			timeReverseUpdate(TubeValue*10+time->hour0Val,time->min,time->sec);
		}else if(TubeValue==2 && time->hour0Val<4){
			timeReverseUpdate(TubeValue*10+time->hour0Val,time->min,time->sec);
		}
		break;
	case hour0:
		if(time->hour1Val<2){
			timeReverseUpdate(time->hour1Val*10+TubeValue,time->min,time->sec);
		}else if(time->hour1Val == 2 && TubeValue<4){
			timeReverseUpdate(time->hour1Val*10+TubeValue,time->min,time->sec);
		}
		
		break;
	case min1:
		if(TubeValue<=5){
			timeReverseUpdate(time->hour,TubeValue*10+time->min0Val,time->sec);
		}
		break;
	case min0:
		timeReverseUpdate(time->hour,time->min1Val*10+TubeValue,time->sec);
		break;
	case sec1:
		if(TubeValue<=5){
			timeReverseUpdate(time->hour,time->min,TubeValue*10+time->sec0Val);
		}
		break;
	case sec0:
		timeReverseUpdate(time->hour,time->min,time->sec1Val*10+TubeValue);
		break;
	
		
	default:
		break;
	}

}
void bluetoothHandle(void){
	if(firstEnterMode){
		twinkling=0;
		firstEnterMode=0;
	R_PG_IO_PORT_Write_P30(1); //on bluetooth
	R_PG_IO_PORT_Write_P31(0); //off fm radio
	}
	if(muteFlag){
		R_PG_IO_PORT_Write_P30(0);
		R_PG_IO_PORT_Write_P31(0);
	}else
	{
		R_PG_IO_PORT_Write_P30(1);
		R_PG_IO_PORT_Write_P31(0);
	}

}
void FMradioHandle(void){
	if(firstEnterMode){
		twinkling=0;
		firstEnterMode=0;
		R_PG_IO_PORT_Write_P30(0); //OFF bluetooth
		R_PG_IO_PORT_Write_P31(1); //on fm radio
		tea5767SetFrequency(98900000);
	}
	if(muteFlag){
		R_PG_IO_PORT_Write_P30(0);
		R_PG_IO_PORT_Write_P31(0);
	}else
	{
		R_PG_IO_PORT_Write_P30(0);
		R_PG_IO_PORT_Write_P31(1);
	}
	
}




void ledControl(unsigned char led,unsigned char colorValue){
	/*
	0x0 off
	0x1 R
	0x2 G
	0x3 yellow
	0x4 B
	0x5 purple
	0x6 sky Blue
	0x7 white
	 */ 
	ledData[led*4+1] = !(colorValue&0x1);
	ledData[led*4+2] = !(colorValue&0x2);
	ledData[led*4+3] = !(colorValue&0x4);
}
void RGBledControl(unsigned char led,unsigned char color){
	if(led & 0x1){
		ledControl(0,color);
	}
	if(led & 0x2 ){
		ledControl(1,color);
	}
	if(led & 0x4 ){
		ledControl(2,color);
	}
	if(led & 0x8 ){
		ledControl(3,color);
	}
	if(led & 16 ){
		ledControl(4,color);
	}
	if(led & 32 ){
		ledControl(5,color);
	}
}

void RGBledPWM(unsigned char led,unsigned char color,unsigned char bright){


	if(bright==cmt1Count){
		RGBledControl(led,0);
		RGBledUpdate();
	}else if(cmt1Count==0){
		RGBledControl(led,color);
		RGBledUpdate();
	}
	
}
void RGBledUpdate(void){
	
	
	R_PG_IO_PORT_Write_P92(0);//latch pin to low
	for(i=0;i<24;i++){
		R_PG_IO_PORT_Write_P94(ledData[23-i]); //data
		R_PG_IO_PORT_Write_P91(1);
		R_PG_IO_PORT_Write_P91(0);  
	}
	R_PG_IO_PORT_Write_P92(1); 
}

void ledRest(void){
	R_PG_IO_PORT_Write_P94(0); //data
	R_PG_IO_PORT_Write_P91(0); //shift
	R_PG_IO_PORT_Write_P92(0); //storge
	R_PG_IO_PORT_Write_P93(0); //output en 0==output enable
	R_PG_IO_PORT_Write_P76(0); //rest low==rest
	R_PG_IO_PORT_Write_P76(1);
	
}

void RestValue(void){
	time->totalSec =50400;
	time->hour=0;
	time->min=0;
	time->sec=0;
}
//per 10ms
unsigned char sinArray[255]={3,3,6,9,13,16,19,22,25,28,31,34,38,41,44,47,50,53,56,59,62,65,68,71,74,77,80,83,86,89,92,95,98,101,104,107,109,112,115,118,121,123,126,129,132,134,137,140,142,145,147,150,152,155,157,160,162,165,167,169,172,174,176,179,181,183,185,187,190,192,194,196,198,200,202,203,205,207,209,211,213,214,216,218,219,221,222,224,225,227,228,230,231,232,234,235,236,237,238,239,241,242,243,243,244,245,246,247,248,248,249,250,250,251,251,252,252,253,253,254,254,254,254,255,255,255,255,255,255,255,255,255,255,254,254,254,254,253,253,252,252,251,251,250,250,249,248,248,247,246,245,244,243,243,242,241,239,238,237,236,235,234,232,231,230,228,227,225,224,222,221,219,218,216,214,213,211,209,207,205,203,202,200,198,196,194,192,190,187,185,183,181,179,176,174,172,169,167,165,162,160,157,155,152,150,147,145,142,140,137,134,132,129,126,123,121,118,115,112,109,107,104,101,98,95,92,89,86,83,80,77,74,71,68,65,62,59,56,53,50,47,44,41,38,34,31,28,25,22,19,16,13,9,6,3};
unsigned char cmt2Count=0;
void Cmt2IntFunc(){
	if(breathFlag == 1){
		
	//	brightValue = sinArray[cmt2Count];
	//	cmt2Count++;
		brightValue++;
		if(brightValue>=254){
			brightValue=0;
		}
	}
}
//per 500ms
void Cmt0IntFunc(){
	if(OneSecFlag == 1){
		if(pauseFlag){
		}else{
			if(time->totalSec >= 86400){
				time->totalSec =0;
			}else{
				time->totalSec++;
			}
		}

		if(enTubeFlag){
			timeUpdate();
		}

	}else{
		if(twinkling){
			ControlTube(setTimeFLag,0xf);
			updateTube();
		}
	}
	OneSecFlag = !OneSecFlag;
}




//per 100us
void Cmt1IntFunc(){
	if(cmt1Count<255){
		cmt1Count++;
	}else{
		cmt1Count = 0;
	}
	RGBledPWM(ledValue,colorValue,brightValue);

}

//per 1ms
void Cmt3IntFunc(){
	if(msCount<50){
		msCount++;
	}
}
void Irq0IntFunc(){
	timerValue = msCount;
	msCount=0;
	pulseCount++;
	R_PG_Timer_SetCounterValue_CMT_U1_C3(0);
    if((timerValue>=50)) // If the pulse width is greater than 50ms, this will mark the SOF
    { 
        pulseCount = -2; // First 2 counts needs to be skipped hence pulse count is set to -2 
        bitPattern = 0;
    }
    else if((pulseCount>=0) && (pulseCount<32)) //Accumulate the bit values between 0-31.
    {  
        if(timerValue>=2)                      //pulse width greater than 2ms is considered as LOGIC1
        {
            bitPattern |=(unsigned long)1<<(31-pulseCount);
        }
        else
        {

        }
    }
    else if(pulseCount>=32)                  //This will mark the End of frame as 32 pulses are received
    {
        newKey = bitPattern;                // Copy the newKey(patter) and set the pulse count to 0;
        pulseCount = 0;
    }
}

void TubeRest(void){	
	R_PG_IO_PORT_Write_P71(0); //data
	R_PG_IO_PORT_Write_P72(0); //shift
	R_PG_IO_PORT_Write_P73(0); //storge
	R_PG_IO_PORT_Write_P74(0); //output en 0==output enable
	R_PG_IO_PORT_Write_P75(0); //rest low==rest
	R_PG_IO_PORT_Write_P75(1);
	

	for(i=0;i<6;i++){
		ControlTube(i,0xf);
	}
	updateTube();
	
}
void ControlTube(unsigned int tube,unsigned int num){
	if(num == 0xf){
		data[tube*4] = 1;
		data[tube*4+1] = 1;
		data[tube*4+2] = 1;
		data[tube*4+3] = 1;

	}else{
		unsigned int A,B,C,D;
		D=num/8;
		C=num/4-D*2;
		B=num/2-C*2-D*4;
		A=num%2;

		data[tube*4] = C;
		data[tube*4+1] = B;
		data[tube*4+2] = D;
		data[tube*4+3] = A;

	}

}
void updateTube(void){
	R_PG_IO_PORT_Write_P73(0);//latch pin to low
	for(i=0;i<24;i++){
		R_PG_IO_PORT_Write_P71(data[23-i]); //data
		R_PG_IO_PORT_Write_P72(1);
		R_PG_IO_PORT_Write_P72(0);  
	}
	R_PG_IO_PORT_Write_P73(1); 
}

void IIC0MasterReFunc(){
	f_IICRX=0;
}
void IIC0MasterTrFunc(){
	f_IICTX=0;
}

void FMsend(unsigned char* buffer){
	R_PG_I2C_MasterSendWithoutStop_C0(0xc0,buffer,5);
 	//while(f_IICTX);
 	//f_IICTX=1;
 	for(i=0;i<888888;i++);
}

void tea5767SetFrequency( unsigned long frequency )
{
  unsigned long pllValue;
  unsigned char buffer[5] = { 0, 0, 0, 0, 0 };
  


  // Calculate PLL word for high side injection mode
  // NDEC = (4*(FRF + FIF)) / FREFS
  // where:
  // FRF = Desired tuning frequency in Hz
  // FIF = Intermediate frequency in Hz (225kHz)
  // FREFS = Reference frequency in Hz (32.768kHz)
  pllValue = (4 * (frequency + 225000)) / 32768;
  
  buffer[0] = (pllValue >> 8) & 0x3F;              // Upper 6 PLL bits (also turns mute and search mode off!)
  buffer[1] = (pllValue & 0xFF);                   // Lower 8 PLL bits
  buffer[2] = (1<<4);//TEA5767_WBYTE3_HLSI;                 // High side injection mode
  buffer[3] = (1<<4);//TEA5767_WBYTE4_XTAL ;// TEA5767_WBYTE4_STEREONOISECANCEL;                 // XTAL bit = 1 for 32.768kHz crystal
  buffer[4] = 0;                                   // PLLREF bit = 0 for 32.768kHz crystal

  // Send data over I2C
  FMsend(buffer);
}



#ifdef __cplusplus
void abort(void)
{

}
#endif
